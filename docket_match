#!/bin/env perl
$|=1;
use strict;
use JSON;
use Scalar::Util qw(looks_like_number);
my $lphbin = "/users/gglusman/proj/DOCKET/data-fingerprints";
my $cutoff = 0.8;
my(@files) = @ARGV;

# Collect dockets to be matched
my @dockets;
foreach my $file (@files) {
	if ($file =~ /^@/) {
		open F, $file;
		while (<F>) {
			chomp;
			my($d) = split /\t/;
			if (looks_like_a_docket($d)) {
				push @dockets, $d;
			} else {
				print "#doesn't look like a docket: $d\n";
			}
		}
		close F;
	} else {
		if (looks_like_a_docket($file)) {
			push @dockets, $file;
		} else {
			print "#doesn't look like a docket: $file\n";
		}
	}
}
die "Not enough dockets to match\n" unless scalar @dockets>1;

# Step 1: find candidate matches quickly via comparisons of column histogram fingerprints
my @cand;
foreach my $i (0..$#dockets-1) {
	foreach my $j ($i+1..$#dockets) {
		my(@matching, @seen);
		open MATCH, "$lphbin/searchLPHs.pl $dockets[$i]/fingerprints/cols_hist_fp.fp $dockets[$j]/fingerprints/cols_hist_fp.fp |";
		while (<MATCH>) {
			chomp;
			my($q, $t, $c) = split /\t/;
			last if $c<$cutoff;
			next if $seen[0]{$q};
			next if $seen[1]{$t};
			push @matching, [$q, $t];
			$seen[0]{$q}++;
			$seen[1]{$t}++;
		}
		close MATCH;
		if (@matching) {
			$cand[$i][$j] = \@matching;
		}
	}
}

# Step 2: trim candidate matches by computing Jaccards (categorical) or two-sample Kolmogorov-Smirnov tests (numerical)
foreach my $i (0..$#dockets-1) {
	next unless defined $cand[$i];
	my $datai = read_json("$dockets[$i]/data/cols_hist.json.gz");
	foreach my $j ($i+1..$#dockets) {
		next unless defined $cand[$i][$j];
		my $dataj = read_json("$dockets[$j]/data/cols_hist.json.gz");
		print $dockets[$i], "\n";
		print $dockets[$j], "\n";
		print "Columns matching: ", scalar @{$cand[$i][$j]}, "\n";
		my %stat;
		my %type;
		foreach my $match (@{$cand[$i][$j]}) {
			#next if $match->[0] eq $match->[1];
			my $di = $datai->{$match->[0]};
			die "nothing in $match->[0]\n" unless keys %$di;
			my $dj = $dataj->{$match->[1]};
			die "nothing in $match->[1]\n" unless keys %$dj;
			my $typei = datatype($di);
			my $typej = datatype($dj);
			my $pair = join("\t", $match->[0], $match->[1]);
			if ($typei eq $typej) {
				if ($typei eq 'num') {
					$type{$pair} = 'num';
					$stat{$pair} = 1-KS2s($di, $dj);
				} elsif ($typei eq 'str') {
					$type{$pair} = 'str';
					$stat{$pair} = weighted_jaccard($di, $dj);
				} else {
					$type{$pair} = 'mixed';
					$stat{$pair} = 0;
					#print "both mixed: $match->[0] $match->[1]\n";
				}
			} else {
				$type{$pair} = '$typei$typej';
				$stat{$pair} = 0;
				#print "different types: $typei $typej\n";
			}
			#next unless $jaccard>0.1 || $int_of_i>0.1 || $int_of_j>0.1;
			#print join("\t", $match->[0], $match->[1], $jaccard, $int_of_i, $int_of_j), "\n";
		}
		my @used;
		foreach my $pair (sort {$stat{$b}<=>$stat{$a}} keys %stat) {
			my($m0, $m1) = split /\t/, $pair;
			next if $used[0]{$m0} || $used[1]{$m1};
			print join("\t", $stat{$pair}, $type{$pair}, $pair), "\n";# unless $m0 eq $m1;
			$used[0]{$m0}++;
			$used[1]{$m1}++;
		}
		
		print "\n";
	}
	
}

sub datatype {
	my($what) = @_;
	my($num, $str);
	while (my($key) = each %$what) {
		next unless $key;
		next if $key eq 'NA';
		if (looks_like_number($key)) {
			$num++;
		} else {
			$str++;
		}
	}
	return 'num' unless $str;
	return 'str' unless $num;
	return 'mixed';
}


sub KS2s { #two-sample Kolmogorov-Smirnov test
	my($di, $dj) = @_;
	
	my(%cumul, $ti, $tj, $ci, $cj, $max, $d);
	foreach my $key (sort {$a<=>$b} keys %$di) {
		$ti += $di->{$key};
		$cumul{$key}[0] = $ti;
	}
	foreach my $key (sort {$a<=>$b} keys %$dj) {
		$tj += $dj->{$key};
		$cumul{$key}[1] = $tj;
	}
	$ci = $cj = $max = 0;
	foreach my $key (sort {$a<=>$b} keys %cumul) {
		$ci = ($cumul{$key}[0]/$ti) || $ci;
		$cj = ($cumul{$key}[1]/$tj) || $cj;
		$d = abs($ci-$cj);
		$max = $d if $d>$max;
	}
	return $max;
}


sub weighted_jaccard {
	my($di, $dj) = @_;
	
	my %union = %$di;
	my %intersection = %$di;
	while (my($key, $value) = each %$di) {
		my $jvalue = $dj->{$key};
		if (defined $jvalue) {
			if ($jvalue > $intersection{$key}) {
				$union{$key} = $jvalue;
			} else {
				$intersection{$key} = $jvalue;
			}
		} else {
			delete $intersection{$key};
		}
	}
	while (my($key, $value) = each %$dj) {
		$union{$key} = $value unless defined $intersection{$key};
	}
	
	my $int_size = 0;
	$int_size += $_ foreach values %intersection;
	my $union_size = 0;
	$union_size += $_ foreach values %union;
	return $int_size / $union_size;
}


sub jaccard {
	my($di, $dj) = @_;
	
	my %union = %$di;
	my %intersection;
	while (my($key) = each %$di) {
		$intersection{$key}++ if defined $dj->{$key};
	}
	while (my($key) = each %$dj) {
		$union{$key}++;
	}
	my $int_size = scalar keys %intersection;
	my $union_size = scalar keys %union;
	return $int_size / $union_size;
	#my $int_of_i = $int_size / scalar keys %$di;
	#my $int_of_j = $int_size / scalar keys %$dj;
}












#########################
sub read_json {
	my($file) = @_;
	my $json;
	open J, "gunzip -c $file |";
	while (<J>) {
		chomp;
		$json .= $_;
	}
	close J;
	return decode_json($json);
}


sub looks_like_a_docket {
	my($dir) = @_;
	
	return 1 if
		-d $dir && 
		-d "$dir/analyses" && 
		-d "$dir/fingerprints" && 
		-d "$dir/comparisons" && 
		-d "$dir/visualizations";
}

