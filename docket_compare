#!/bin/env perl
$|=1;
use strict;
use JSON;
my(@files) = @ARGV;
my $kg = "knowledgegraphs";

# Collect dockets to be compared
my @dockets;
my %graphFiles;
foreach my $file (@files) {
	if ($file =~ /^@/) {
		open F, $file;
		while (<F>) {
			chomp;
			my($d) = split /\t/;
			if (looks_like_a_docket($d)) {
				push @dockets, $d;
				foreach (fulldirlist("$d/$kg")) {
					$graphFiles{$1}{$d}++ if /(.+)\.json(\.gz)?$/;
				}
			} else {
				print "#doesn't look like a docket: $d\n";
			}
		}
		close F;
	} else {
		if (looks_like_a_docket($file)) {
			push @dockets, $file;
			foreach (fulldirlist("$file/$kg")) {
				$graphFiles{$1}{$file}++ if /(.+)\.json(\.gz)?$/;
			}
		} else {
			print "#doesn't look like a docket: $file\n";
		}
	}
}
die "Not enough dockets to compare\n" unless scalar @dockets>1;
@dockets = sort @dockets;
#print scalar @dockets, " dockets to compare\n";
#print join("\t", keys %graphFiles), "\n";

foreach my $graph (sort keys %graphFiles) {
	my @docketsWithGraph = sort keys %{$graphFiles{$graph}};
	next unless scalar @docketsWithGraph>1;
	my %info;
	my %stat;
	foreach my $d (@docketsWithGraph) {
		my $json = read_json("$d/$kg/$graph.json.gz");
		foreach my $key (keys %$json) {
			if ($key eq 'tests') {
				# ingest all test results
				foreach my $blob (@{$json->{$key}}) {
					my $pair = join("\t", $blob->{'A'}, $blob->{'B'});
					foreach my $stat (keys %$blob) {
						next if $stat eq 'A' || $stat eq 'B';
						$stat{$pair}{$stat}{$d} = $blob->{$stat};
					}
				}
			} else {
				$info{$key}{$json->{$key}}++;
			}
		}
	}
	foreach my $key (sort keys %info) {
		print join("\t", $graph, $key, %{$info{$key}}), "\n";
	}
	foreach my $pair (sort keys %stat) {
		foreach my $stat (sort keys %{$stat{$pair}}) {
			next if scalar keys %{$stat{$pair}{$stat}}<2;
			print join("\t", $stat, map({$stat{$pair}{$stat}{$_} // 'NA'} @docketsWithGraph), $pair), "\n";
		}
	}
}

exit;
# Step 1: compare num_assoc output
my(%n, %rho, %pval);
foreach my $i (0..$#dockets) {
	next unless -e "$dockets[$i]/comparisons/num_assoc.gz";
	open RES, "gunzip -c $dockets[$i]/comparisons/num_assoc.gz |";
	while (<RES>) {
		next if /^#/;
		chomp;
		my($q, $t, $n, $rho, $p) = split /\t/;
		next if $q eq 'variableA';
		($q, $t) = sort ($q, $t);
		my $id = join("\t", $q, $t);
		push @{$n{$id}}, $n;
		push @{$rho{$id}}, $rho;
		push @{$pval{$id}}, $p;
	}
	close RES;
}


foreach my $id (keys %n) {
	next unless scalar @{$rho{$id}}>10;
	my($ravg, $rstd) = avgstd($rho{$id});
	my($pavg, $pstd) = avgstd($pval{$id});
	print join("\t", $n{$id}[0], $n{$id}[-1], $ravg, $rstd, $pavg, $pstd, $id), "\n";
}








#########################
sub read_json {
	my($file) = @_;
	my $json;
	open J, "gunzip -c $file |";
	while (<J>) {
		chomp;
		$json .= $_;
	}
	close J;
	return decode_json($json);
}


sub looks_like_a_docket {
	my($dir) = @_;
	
	return 1 if
		-d $dir && 
		-d "$dir/analyses" && 
		-d "$dir/fingerprints" && 
		-d "$dir/comparisons" && 
		-d "$dir/visualizations";
}

sub avgstd {
	my($values) = @_;
	my($sum, $devsqsum);

	my $n = scalar @$values;
	return unless $n>1;
	foreach (@$values) { $sum += $_ }
	my $avg = $sum / $n;
	foreach (@$values) { $devsqsum += ($_-$avg)**2 }
	my $std = sqrt($devsqsum/($n-1));
	return $avg, $std;
}

sub fulldirlist {
	my($dir) = @_;
	opendir (DIR, $dir);
	my @files = grep /^[^.]/, readdir DIR;
	closedir DIR;
	return @files;
}

